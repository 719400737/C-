分为3个部分，
1.IO处理单元：处理客户连接，读写网络数据
2.逻辑单元：业务进程或线程
3.网络存储单元：本地数据库，文件或缓存

请求队列是个单元之间的通信方式的抽象，Io处理单元接受到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。


IO复用的高级应用之一：非阻塞connect，用于提高并发型，阻塞的connect，当进程进行connect时，进程被阻塞，什么都不能干，但非阻塞connect，可以调用select和epoll等来监听，使用非阻塞方式，我们可以同时发起多个链接，并一起等待。

Reactor: 要求主线程，只负责监听文件描述符上是否有事情发生，有的话就立即通知工作线程数据的读写，接受新的链接以及处理客户请求均在工作线程中完成，除此之外，逻辑线程不做任何工作。
1.主线程往epoll内核事件表中注册socket上的读就绪事件
2.主线程调用epoll_wait等待socket上有数据可读，
3.有数据时，epollwait通知主线程，主线程将socket可读事件放入请求队列。
4.睡眠在请求队列上的某个工作线程被唤醒，从socket读取数据，处理客户请求，epoll内核事件表中注册socket上的写就绪事件。
5.主线程调用epollwait等待可写。
6、当可写时，epollwait通知主线程，主线程将socket可写放入请求队列。
7.唤醒工作线程，处理请求。

proactor：将所有Io操作交给主线程和内核来处理，工作线程仅仅负责业务逻辑。
1.主线程调动aioread向内核注册socket上的读完成事件，并告诉内核用户缓冲区位置，以及读操作完成时如何通知应用程序（可以使用信号）。
2.主线程继续处理其他逻辑。
3.当socket上的读数据被读入用户缓冲区后，内核向应用进程发送一个信号，通知程序数据已经可用。
4.应用程序预先定义好的信号处理函数使用一个工作线程来处理客户请求，工作线程处理完客户请求后，调用aiowrite向内核注册socket完成事件，告诉内核缓冲区位置，以及操作完成后如何通知应用程序（可以使用信号）。
5.主线程继续其他逻辑。
6.当用户缓冲区被写入socket后，内核将向应用程序发送一个信号，通知应用程序数据已经发送完毕。
7.应用程序预先定义好信号处理函数，选择一个工作线程来善后处理，比如是否关闭socket。



浏览器中的GET和POST：
GET：读取一个资源。比如Get到一个html文件，反复读取不应该对访问数据有副作用。没有副作用被成为幂等。GET因为是读取，就可以对GET请求的数据做缓存，这个缓存可以做到浏览器本身上(彻底避免浏览器发请求)，可以做到代理上，也可以坐在server端。

POST：在页面里<form>标签会定义一个表单，点击submit元素会发出一个POST请求会让服务器做一件事，这件事往往是有副作用的，不幂等的。


条件变量：
条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个进程，直到某种特殊情况发生，通常条件变量和互斥锁同时使用。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使 "条件成立"（给出条件成立信号）。

